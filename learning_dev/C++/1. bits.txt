YouTube: The Cherno (Intro to Binary and Bitwise Operators in C++)
Arithmetic Operators: + - / *
Bitwise Operators (Base 2 number system):

1) << : Bitshift Left
2) >> : Bitshift Right
3)  & : AND Operator
4)  | : OR Operator
5)  ^ : XOR Operator
6)  ~ : NOT Operator

You can definitely overload/override these operators. ["bitshifts" => "cout"]
In our computers: We have capacitors where below a certain threshold of current, it falls into OFF state, otherwise ON state.
This is how our RAM stores data. Binary system uses 0,1 numbers.
Five is 101. Int is 4 bytes. In memory -> 0000 0101 0000 0000. Location is dependant on "Network Data Management System (NDM) . . .?" 
Least Significant Bit is stored at left at lower memory address. 

Bitshift Left/Right shift the bits by the amount of number specified.
    int a = 5;          // Declaring that the value at &a is 0000 0101 0000 0000.
    a <<= 1;            [Imagine like "+="] // Here, the bits of a are shifted to left by 1.
    cout<<a             // = 10 now as it is now 0000 1010 0000 0000.
    a >>= 1;            // Bits are shifted to right by 1.
    cout<<a             // = 5.
Hence, bitshift left doubles the number, bitshift right halves it 
// (integer division only! Extra bits are dropped off the edge of the world during right shift or overflow left shift).
Changing the digit makes it 2^n where n is the digit changed. a <<= 3 gives a * 2^3, or when a equals 5, a <<= 3 equals 40.

Use the & operator to perform masking on the target bit as we know that only in the case of 1 & 1 is the output bit 1.
This property lets us create our own mask bit number that we can then "AND" with the question bit, and everywhere else is 0.
The output of this AND operation is either only 0 or >0 depending on either case. Which lets us pass that result into an if statement
to act according to various values.
Or operator works similar to OR logical function and similar to what we've written upside. The only difference is that its used to Add bits instead
of taking away the bits and also we need to do a left shift of the useless places for our target bit before we actually perform the "or" operation.

Write directly in binary using 0b (pattern of binary required from C++14) =>
int a = 0b101;
int b = 0b10110;
// Remember that each set is divided into 4 bits.
// So here, we shift b by 4 instead of 3 to add 10110 to 101 (or 0101 essentially in computer terms).
b <<= 4;
int c = a | b;
c = 101100101

Bitwise operator NOT can be used with AND (mask and isolate with 1) to mask and flip the on bits off! Performs the function of 1 basically to flip bits on but using AND and NOT
For example: 
1100 is our original. Create a target mask for the 3rd bit -> 0100. & them -> 0100, ~ them -> 1011, & with original -> 1000.
In our final answer, we managed to turn off the third bit successfully!

XOR is mostly used in hashing. XOR with itself is always 0. 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

YouTube: CodeVault (Practical uses of bitwise operations)
